% 
% Generate Septuple Block Diagonal 3D Tensor
% 
% OUTPUT = SEPDIAG2D(N, X, VARARGIN)
%   Return the general sepdiagonal block 3 level tensor
%   That is
% 
%             A = sepdiag(B, C, C, C, C, C, C)
% 
%   What's more, all blocks are also septuple diagonal tensors as
% 
%             B = sepdiag(b_0, b_1, b_1, b_1, b_1, b_1, b_1)
% 
%             C = sepdiag(c_0, c_1, c_1, c_1, c_1, c_1, c_1)
%   
%   which means A has 'perfect shuffle' symmetry
% 
%   [Input Argument]
%       n - Scalar, not less than 2, size of the tensor, the output will be
%           a (n^2) x (n^2) x (n^2) tensor
%       x - Scalar, x = [b_0 b_1 c_0 c_1] specifes main and sub/super 
%           diagonal entries
%       sp - Boolen, optional, whether the output is reshaped into a sparse
%            matrix by merging the first two modes (1: yes, 0: no), set it
%            as 1 if the output is used to be multiplied by a vector 
%            (default: 0)
% 
%   [Ouput Argument]
%       output - Array, the output tensor
% 
% Details:
%   1. If A is the tensor generated by integration of three piecewise
%      linear basis functions of an equidistant grid on a square area:
% 
%         A(i, j, k) = ∫_Ω (f_i(x, y) * f_j(x, y) * f_k(x, y)) dx dy
%       
%      Ω = [d_1, d_2] x [e_1, e_2] is the domain
% 
%      f_i(x, y) = [1-|x-x_i|/h_x][1-|y-y_i|/h_y] (i∈{1, ... , n^2}) is the
%      basis function w.r.t. node i (in global indexing)
% 
%      h_x, h_y are spacing of each element on X, Y axis
% 
%      then A can be generated by code
% 
%                A = sepdiag2d(n, [36 2 6 1]*h_x*h_y/144);
% 
%   2. If sp = 1, the output will be B = (A(ij, k)) ∈ R^{(n^4) x (n^2)}, 
%      then we can calculate A * v by B * v = C and seperate the modes of C
%      to get the final answer (v is an arbitary vector) as codes below
% 
%                         B = sepdiag(n, x, 1);
%                         C = B*v;
%                         C = reshape(C, [n^2 n^2]);


function output = sepdiag2d(n, x, varargin)
    % Input number check
    if nargin == 2
        sp = 0;
    elseif nargin == 3
        sp = varargin{1};
    else
        error('Input number should be 2 or 3!');
    end


    % Input type check
    if ~isnumeric(n) || ~isscalar(n)
        error('Tensor size should be a numeric scalar!');
    elseif n < 2 || mod(n, 1) ~= 0
        error('Tensor size should be an integer not less than 2!');
    elseif ~isnumeric(x) || ~isvector(x)
        error('Entries should be a numeric vector!');
    elseif length(x) ~= 4
        error('Entries should be length-4!');
    elseif ~isnumeric(sp) || ~isscalar(sp)
        error('Sparsity flag should be a numeric scalar!');
    elseif sp ~= 0 && sp ~= 1
        error('Sparsity flag should be 0 or 1!');
    end

    
    % Assemble output
    if sp % Sparse output
        % Intialization
        output = sparse(n^4, n^2);

        % Scanning
        for K = 1:n % Each block is a n x n x n 3 level tensor, K is the 
                    % horizontal index for blocks
            % Intialization of position matrices
            [main_pos, sub_pos] = deal(sparse(n, n));

            % Position of main block
            main_pos(K, K) = 1;

            % Positions of sub/super diagonal blocks
            if K < n
                sub_pos(K:(K+1), K:(K+1)) = [0 1; 1 1];
            end
            if 1 < K
                sub_pos((K-1):K, (K-1):K) = [1 1; 1 0];
            end
            
            % Assemble blocks
            for k = 1:n % k is the local horizontal index for each block
                tmp = sparse(n^2, n^2); % Horizontal slice of output
                [main_tmp, sub_tmp] = deal(sparse(n, n)); % Horizontal 
                                                          % slices of 
                                                          % blocks
                % Horizontal slice of main block
                if k < n
                    main_tmp(k:(k+1), k:(k+1)) = [x(1) x(2); x(2) x(2)];
                end
                if 1 < k
                    main_tmp((k-1):k, (k-1):k) = [x(2) x(2); x(2) x(1)];
                end

                % Horizontal slice of sub/super diagonal block
                if k < n
                    sub_tmp(k:k+1, k:k+1) = [x(3) x(4); x(4) x(4)];
                end
                if 1 < k
                    sub_tmp(k-1:k, k-1:k) = [x(4) x(4); x(4) x(3)];
                end

                % Assemble horizontal slice
                tmp = kron(main_pos, main_tmp)+kron(sub_pos, sub_tmp);
                output(:, (K-1)*n+k) = reshape(tmp, [n^4 1]);
            end
        end

    else % Dense output
        % Intialization
        output = zeros(n^2, n^2, n^2);
    
        % Generate blocks
        main_block = sepdiag1d(n, [x(1) repmat(x(2), 1, 6)]);
        sub_block = sepdiag1d(n, [x(3) repmat(x(4), 1, 6)]);
    
        % Assemble blocks
        output = tkron(sepdiag1d(n, [1 0 0 0 0 0 0]), main_block) + ...
                 tkron(sepdiag1d(n, [0 1 1 1 1 1 1]), sub_block);
    end


end