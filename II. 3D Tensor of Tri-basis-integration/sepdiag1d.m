% 
% Generate Septuple Diagonal 3D Tensor
% 
% OUTPUT = SEPDIAG1D(N, X, VARARGIN)
%   Return the general sepdiagonal 3 level tensor
%   That is
% 
%             A = sepdiag(x_0, x_1, x_2, x_3, x_4, x_5, x_6)
% 
%   p-th horizontal slice of A is (a 2^d x 2^d matrix, index i/j increases 
%   from left to the right/bottom to the top)
%   
%               [                  ]
%               [        x_2  x_3  ]
%               [   x_4  x_0  x_1  ] → j=p (p∈{1, ... , 2^d})
%               [   x_6  x_5       ]
%               [                  ]
%                         ↓
%                        i=p
% 
%   [Input Argument]
%       n - Scalar, not less than 2, size of the tensor, the output will be
%           a n x n x n tensor
%       x - Scalar, x = [x_0 x_1 x_2 x_3 x_4 x_5 x_6] specifes main and 
%           sub/super diagonal entries
%       sp - Boolen, optional, whether the output is reshaped into a sparse
%            matrix by merging the first two modes (1: yes, 0: no), set it
%            as 1 if the output is used to be multiplied by a vector 
%            (default: 0)
% 
%   [Ouput Argument]
%       output - Array, the output tensor
% 
% Details:
%   1. If A is the tensor generated by integration of three piecewise
%      linear basis functions of an equidistant grid on a closed interval:
% 
%               A(i, j, k) = ∫_Ω (f_i(x) * f_j(x) * f_k(x)) dx
%       
%      Ω = [d_1, d_2] is the domain
% 
%      f_i(x) = [1-|x-x_i|/h_x] (i∈{1, ... , n^2}) is the basis function 
%      w.r.t. node i (in global indexing)
% 
%      h_x is the spacing of each element on X axis
% 
%      then A can be generated by code
% 
%                 A = sepdiag1d(n, [6 5 5 5 5 5 5]*h_x/12);
% 
%   2. If sp = 1, the output will be B = (A(ij, k)) ∈ R^{(n^2) x n}, then 
%      we can calculate A * v by B * v = C and seperate the modes of C to 
%      get the final answer (v is an arbitary vector) as codes below
% 
%                           B = sepdiag(n, x, 1);
%                           C = B*v;
%                           C = reshape(C, [n n]);


function output = sepdiag1d(n, x, varargin)
    % Input number check
    if nargin == 2
        sp = 0;
    elseif nargin == 3
        sp = varargin{1};
    else
        error('Input number should be 2 or 3!');
    end


    % Input type check
    if ~isnumeric(n) || ~isscalar(n)
        error('Tensor size should be a numeric scalar!');
    elseif n < 2 || mod(n, 1) ~= 0
        error('Tensor size should be an integer not less than 2!');
    elseif ~isnumeric(x) || ~isvector(x)
        error('Entries should be a numeric vector!');
    elseif length(x) ~= 7
        error('Entries should be length-7!');
    elseif ~isnumeric(sp) || ~isscalar(sp)
        error('Sparsity flag should be a numeric scalar!');
    elseif sp ~= 0 && sp ~= 1
        error('Sparsity flag should be 0 or 1!');
    end


    % Assemble output
    if sp % Sparse output
        output = sparse(n^2, n);
        for p = 1:n
            if p == 1
                output(1, p) = x(1);
                output(2, p) = x(2);
                output(n+1, p) = x(3);
                output(n+2, p) = x(4);
            elseif p == n
                output(n^2, p) = x(1);
                output(n^2-1, p) = x(5);
                output(n*(n-1), p) = x(6);
                output(n*(n-1)-1, p) = x(7);
            else
                output(p+n*(p-1), p) = x(1);
                output(p+1+n*(p-1), p) = x(2);
                output(p+n*p, p) = x(3);
                output(p+1+n*p, p) = x(4);
                output(p-1+n*(p-1), p) = x(5);
                output(p+n*(p-2), p) = x(6);
                output(p-1+n*(p-2), p) = x(7);
            end
        end

    else % Dense output
        output = zeros(n, n, n);
        for p = 1:n
            if p == 1
                output(1, 1, p) = x(1);
                output(2, 1, p) = x(2);
                output(1, 2, p) = x(3);
                output(2, 2, p) = x(4);
            elseif p == n
                output(n, n, p) = x(1);
                output(n-1, n, p) = x(5);
                output(n, n-1, p) = x(6);
                output(n-1, n-1, p) = x(7);
            else
                output(p, p, p) = x(1);
                output(p+1, p, p) = x(2);
                output(p, p+1, p) = x(3);
                output(p+1, p+1, p) = x(4);
                output(p-1, p, p) = x(5);
                output(p, p-1, p) = x(6);
                output(p-1, p-1, p) = x(7);
            end
        end

    end


end