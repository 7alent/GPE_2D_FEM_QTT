% 
% Generate the QTT of Sepdiagonal 3 Level Block Tensors in 2-D FEM
% 
% TT = TT_QSEPDIAG2D(D, X)
%   Return the exact QTT representation of a sepdiagonal block 3 level 
%   tensor whose sub/super diagonal blocks are the same, and all main 
%   diagonal blocks are the same as well
%   That is
% 
%                      A = sepdiag(B, C, C, C, C, C, C)
% 
%   What's more, all blocks are also septuple diagonal tensors as
% 
%               B = sepdiag(b_0, b_1, b_1, b_1, b_1, b_1, b_1)
% 
%               C = sepdiag(c_0, c_1, c_1, c_1, c_1, c_1, c_1)
%   
%   which means A has 'perfect shuffle' symmetry
% 
%   [Input Argument]
%       d - Scalar, not less than 2, level of the mesh grid size, total 
%           element number will be (2^d+1)^2
%       x - Scalar, x = [b_0 b_1 c_0 c_1] specifes main and sub/super 
%           diagonal entries of blocks
% 
%   [Ouput Argument]
%       tt - Cell array, QTT of the output tensor
% 
% Details:
%   1. A has QTT representation as
% 
%       A = E_1 * G^(d-2) * [N_d P_d] * [I  O ] * [I O]^(d-2) * [ I ]
%                                       [O E_1]   [O G]         [Q_d]
% 
%      with
% 
%         E_1 = [I, J_1_hat, J_2_hat, J_3_hat, J_1, J_2, J_3]
% 
%         G = [I  J_1_hat  J_2_hat  J_3_hat  J_1       J_2       J_3    ]
%             [   J_1                                                   ]
%             [            J_2                                          ]
%             [                     J_3                                 ]
%             [                              J_1_hat                    ]
%             [                                        J_2_hat          ]
%             [                                                  J_3_hat]
% 
%         N_d = [b_0 * I + c_0 * Σ(J_l_hat + J_l)]
%               [           c_0 * J_1            ]
%               [           c_0 * J_2            ]
%               [           c_0 * J_3            ]
%               [         c_0 * J_1_hat          ]
%               [         c_0 * J_2_hat          ]
%               [         c_0 * J_3_hat          ]
% 
%         P_d = [b_1 * I + c_1 * Σ(J_l_hat + J_l)]
%               [           c_1 * J_1            ]
%               [           c_1 * J_2            ]
%               [           c_1 * J_3            ]
%               [         c_1 * J_1_hat          ]
%               [         c_1 * J_2_hat          ]
%               [         c_1 * J_3_hat          ]
% 
%         Q_d = [Σ(J_l_hat + J_l)]
%               [      J_1       ]
%               [      J_2       ]
%               [      J_3       ]
%               [     J_1_hat    ]
%               [     J_2_hat    ]
%               [     J_3_hat    ]
% 
%   with (index i/j increases from left to the right/bottom to the top)
% 
%         I(:, :, 1)  =  [ 0    0 ]       I(:, :, 2)  =  [ 0    1 ]
%                        [ 1    0 ]                      [ 0    0 ]
% 
%         J_1(:, :, 1) = [ 0    0 ]       J_1(:, :, 2) = [ 1    0 ]
%                        [ 0    0 ]                      [ 0    0 ]
% 
%         J_2(:, :, 1) = [ 0    0 ]       J_2(:, :, 2) = [ 0    0 ]
%                        [ 0    0 ]                      [ 0    1 ]
% 
%         J_3(:, :, 1) = [ 0    0 ]       J_3(:, :, 2) = [ 0    0 ]
%                        [ 0    0 ]                      [ 1    0 ]
% 
%         J_1_hat(:, :, 1) = [0  0]       J_1_hat(:, :, 2) = [0  0]
%                            [0  1]                          [0  0]
% 
%         J_2_hat(:, :, 1) = [1  0]       J_2_hat(:, :, 2) = [0  0]
%                            [0  0]                          [0  0]
% 
%         J_3_hat(:, :, 1) = [0  1]       J_3_hat(:, :, 2) = [0  0]
%                            [0  0]                          [0  0]
% 
%      here * denotes rank core product (⋈) and ^ denotes its power
% 
%   2. If A is the tensor generated by integration of three piecewise
%      linear basis functions of an equidistant grid on a square area:
% 
%         A(i, j, k) = ∫_Ω (f_i(x, y) * f_j(x, y) * f_k(x, y)) dx dy
%       
%      Ω = [d_1, d_2] x [e_1, e_2] is the domain
% 
%      f_i(x, y) = [1-|x-x_i|/h_x][1-|y-y_i|/h_y] (i∈{1, ... , 2^(2*d)}) is
%      the basis function w.r.t. node i (in global indexing)
% 
%      h_x, h_y are spacing of each element on X, Y axis
% 
%      then A can be generated by code
% 
%               A = tt_qsepdiag2d(d, [36 2 6 1]*h_x*h_y/144);


function tt = tt_qsepdiag2d(d, x)
    % Input check
    if nargin ~= 2
        error('Number of inputs should be 2!');
    elseif ~isnumeric(d) || ~isscalar(d)
        error('Level of grid should be a numeric scalar!');
    elseif d < 2 || mod(d, 1) ~= 0
        error('Level of grid should be an integer not less than 2!');
    elseif ~isnumeric(x) || ~isvector(x)
        error('Entries should be a numeric vector!');
    elseif length(x) ~= 4
        error('Entries should be given as a length-4 vector!');
    end


    % Generate blocks
    [I, J_1, J_2, J_3, ...
     J_1_hat, J_2_hat, J_3_hat] = deal(zeros(2, 2, 2));
    I(1, 1, 1) = 1;
    I(2, 2, 2) = 1;
    J_1(1, 2, 2) = 1;
    J_2(2, 1, 2) = 1;
    J_3(1, 1, 2) = 1;
    J_1_hat(2, 1, 1) = 1;
    J_2_hat(1, 2, 1) = 1;
    J_3_hat(2, 2, 1) = 1;

    E_1 = zeros(2, 2, 2, 7);
    E_1(:, :, :, 1) = I;
    E_1(:, :, :, 2) = J_1_hat;
    E_1(:, :, :, 3) = J_2_hat;
    E_1(:, :, :, 4) = J_3_hat;
    E_1(:, :, :, 5) = J_1;
    E_1(:, :, :, 6) = J_2;
    E_1(:, :, :, 7) = J_3;

    G = zeros(2, 2, 2, 7, 7);
    G(:, :, :, 1, 1) = I;
    G(:, :, :, 2, 1) = J_1_hat;
    G(:, :, :, 2, 2) = J_1;
    G(:, :, :, 3, 1) = J_2_hat;
    G(:, :, :, 3, 3) = J_2;
    G(:, :, :, 4, 1) = J_3_hat;
    G(:, :, :, 4, 4) = J_3;
    G(:, :, :, 5, 1) = J_1;
    G(:, :, :, 5, 5) = J_1_hat;
    G(:, :, :, 6, 1) = J_2;
    G(:, :, :, 6, 6) = J_2_hat;
    G(:, :, :, 7, 1) = J_3;
    G(:, :, :, 7, 7) = J_3_hat;
    
    N_d = zeros(2, 2, 2, 7);
    N_d(:, :, :, 1) = x(1)*I+x(3)*(J_1_hat+J_2_hat+J_3_hat+J_1+J_2+J_3);
    N_d(:, :, :, 2) = x(3)*J_1;
    N_d(:, :, :, 3) = x(3)*J_2;
    N_d(:, :, :, 4) = x(3)*J_3;
    N_d(:, :, :, 5) = x(3)*J_1_hat;
    N_d(:, :, :, 6) = x(3)*J_2_hat;
    N_d(:, :, :, 7) = x(3)*J_3_hat;

    P_d = zeros(2, 2, 2, 7);
    P_d(:, :, :, 1) = x(2)*I+x(4)*(J_1_hat+J_2_hat+J_3_hat+J_1+J_2+J_3);
    P_d(:, :, :, 2) = x(4)*J_1;
    P_d(:, :, :, 3) = x(4)*J_2;
    P_d(:, :, :, 4) = x(4)*J_3;
    P_d(:, :, :, 5) = x(4)*J_1_hat;
    P_d(:, :, :, 6) = x(4)*J_2_hat;
    P_d(:, :, :, 7) = x(4)*J_3_hat;

    Q_d = zeros(2, 2, 2, 7);
    Q_d(:, :, :, 1) = J_1_hat+J_2_hat+J_3_hat+J_1+J_2+J_3;
    Q_d(:, :, :, 2) = J_1;
    Q_d(:, :, :, 3) = J_2;
    Q_d(:, :, :, 4) = J_3;
    Q_d(:, :, :, 5) = J_1_hat;
    Q_d(:, :, :, 6) = J_2_hat;
    Q_d(:, :, :, 7) = J_3_hat;


    % Assemble QTT
    tt = cell(2*d, 1);

    tt{1} = zeros(2, 2, 2, 8);
    tt{1}(:, :, :, 1) = I;
    tt{1}(:, :, :, 2:8) = Q_d;
    
    for i = 2:(d-1)
        tt{i} = zeros(2, 2, 2, 8, 8);
        tt{i}(:, :, :, 1, 1) = I;
        tt{i}(:, :, :, 2:8, 2:8) = G;
    end

    tt{d} = zeros(2, 2, 2, 8, 2);
    tt{d}(:, :, :, 1, 1) = I;
    tt{d}(:, :, :, 2:8, 2)= E_1;

    tt{d+1} = zeros(2, 2, 2, 2, 7);
    tt{d+1}(:, :, :, 1, :) = N_d;
    tt{d+1}(:, :, :, 2, :) = P_d;
    
    for i = (d+2):(2*d-1)
        tt{i} = zeros(2, 2, 2, 7, 7);
        tt{i} = G;
    end

    tt{2*d} = zeros(2, 2, 2, 7);
    tt{2*d} = E_1;
    
    
end